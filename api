using librsync.net;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using NLog;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Drawing.Processing;
using SixLabors.ImageSharp.Formats.Png;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Net.WebSockets;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Websocket.Client;

#nullable enable
namespace VRCX;

public abstract class AppApi
{
  private static readonly 
  #nullable disable
  Logger logger = LogManager.GetCurrentClassLogger();
  private static readonly MD5 _hasher = MD5.Create();
  private static readonly Uri _ovrtWebsocketUri = new Uri("ws://127.0.0.1:11450/api");
  private static readonly byte[] _vrcxIcon = Convert.FromBase64String("i
  private static WebsocketClient _ovrtWebsocketClient;
  private static readonly Regex _folderRegex = new Regex(string.Format("([{0}]*\\.+$)|([{0}]+)", (object) Regex.Escape(new string(Path.GetInvalidPathChars()))));
  private static readonly Regex _fileRegex = new Regex(string.Format("([{0}]*\\.+$)|([{0}]+)", (object) Regex.Escape(new string(Path.GetInvalidFileNameChars()))));

  public void Init()
  {
  }

  public string MD5File(string blob)
  {
    byte[] buffer = Convert.FromBase64CharArray(blob.ToCharArray(), 0, blob.Length);
    using (MD5 md5 = MD5.Create())
      return Convert.ToBase64String(md5.ComputeHash(buffer));
  }

  public int GetColourFromUserID(string userId)
  {
    byte[] hash = AppApi._hasher.ComputeHash(Encoding.UTF8.GetBytes(userId));
    return (int) hash[3] << 8 | (int) hash[4];
  }

  public string SignFile(string blob)
  {
    using (Stream signature = Librsync.ComputeSignature((Stream) new MemoryStream(Convert.FromBase64String(blob))))
    {
      using (MemoryStream destination = new MemoryStream())
      {
        signature.CopyTo((Stream) destination);
        return Convert.ToBase64String(destination.ToArray());
      }
    }
  }

  public string FileLength(string blob) => Convert.FromBase64String(blob).Length.ToString();

  public void OpenLink(string url)
  {
    if (!url.StartsWith("http://") && !url.StartsWith("https://"))
      return;
    Process.Start(new ProcessStartInfo(url)
    {
      UseShellExecute = true
    });
  }

  public string GetLaunchCommand()
  {
    string launchCommand = StartupArgs.LaunchArguments.LaunchCommand;
    StartupArgs.LaunchArguments.LaunchCommand = string.Empty;
    return launchCommand;
  }

  public void IPCAnnounceStart()
  {
    IPCServer.Send(new IPCPacket()
    {
      Type = "VRCXLaunch",
      MsgType = "VRCXLaunch"
    });
  }

  public void SendIpc(string type, string data)
  {
    IPCServer.Send(new IPCPacket()
    {
      Type = "VrcxMessage",
      MsgType = type,
      Data = data
    });
  }

  public string CustomCssPath()
  {
    string str = string.Empty;
    string path = Path.Join(Program.AppDataDirectory, "custom.css");
    if (System.IO.File.Exists(path))
      str = path;
    return str;
  }

  public string CustomScriptPath()
  {
    string str = string.Empty;
    string path = Path.Join(Program.AppDataDirectory, "custom.js");
    if (System.IO.File.Exists(path))
      str = path;
    return str;
  }

  public string CurrentCulture()
  {
    string str = CultureInfo.CurrentCulture.ToString();
    if (string.IsNullOrEmpty(str))
      str = "en-US";
    return str;
  }

  public string CurrentLanguage() => CultureInfo.InstalledUICulture.Name;

  public string GetVersion() => Program.Version;

  public bool VrcClosedGracefully() => LogWatcher.Instance.VrcClosedGracefully;

  public Dictionary<string, int> GetColourBulk(List<object> userIds)
  {
    Dictionary<string, int> colourBulk = new Dictionary<string, int>();
    foreach (string userId in userIds)
      colourBulk.Add(userId, this.GetColourFromUserID(userId));
    return colourBulk;
  }

  public void SetAppLauncherSettings(bool enabled, bool killOnExit)
  {
    AutoAppLaunchManager.Instance.Enabled = enabled;
    AutoAppLaunchManager.Instance.KillChildrenOnExit = killOnExit;
  }

  public string GetFileBase64(string path)
  {
    return System.IO.File.Exists(path) ? Convert.ToBase64String(System.IO.File.ReadAllBytes(path)) : (string) null;
  }

  public abstract void ShowDevTools();

  public abstract void SetVR(
    bool active,
    bool hmdOverlay,
    bool wristOverlay,
    bool menuButton,
    int overlayHand);

  public abstract void RefreshVR();

  public abstract void RestartVR();

  public abstract void SetZoom(double zoomLevel);

  public abstract Task<double> GetZoom();

  public abstract void DesktopNotification(string BoldText, string Text = "", string Image = "");

  public abstract void RestartApplication(bool isUpgrade);

  public abstract bool CheckForUpdateExe();

  public abstract void ExecuteAppFunction(string function, string json);

  public abstract void ExecuteVrFeedFunction(string function, string json);

  public abstract void ExecuteVrOverlayFunction(string function, string json);

  public abstract void FocusWindow();

  public abstract void ChangeTheme(int value);

  public abstract void DoFunny();

  public abstract string GetClipboard();

  public abstract void SetStartup(bool enabled);

  public abstract void CopyImageToClipboard(string path);

  public abstract void FlashWindow();

  public abstract void SetUserAgent();

  public abstract bool IsRunningUnderWine();

  public abstract string GetVRChatAppDataLocation();

  public abstract string GetVRChatPhotosLocation();

  public abstract string GetUGCPhotoLocation(string path = "");

  public abstract string GetVRChatScreenshotsLocation();

  public abstract string GetVRChatCacheLocation();

  public abstract bool OpenVrcxAppDataFolder();

  public abstract bool OpenVrcAppDataFolder();

  public abstract bool OpenVrcPhotosFolder();

  public abstract bool OpenUGCPhotosFolder(string ugcPath = "");

  public abstract bool OpenVrcScreenshotsFolder();

  public abstract bool OpenCrashVrcCrashDumps();

  public abstract void OpenShortcutFolder();

  public abstract void OpenFolderAndSelectItem(string path, bool isFolder = false);

  public abstract Task<string> OpenFolderSelectorDialog(string defaultPath = "");

  public abstract Task<string> OpenFileSelectorDialog(
    string defaultPath = "",
    string defaultExt = "",
    string defaultFilter = "All files (*.*)|*.*");

  public abstract void OnProcessStateChanged(MonitoredProcess monitoredProcess);

  public abstract void CheckGameRunning();

  public abstract bool IsGameRunning();

  public abstract bool IsSteamVRRunning();

  public abstract int QuitGame();

  public abstract bool StartGame(string arguments);

  public abstract bool StartGameFromPath(string path, string arguments);

  public abstract object GetVRChatRegistryKey(string key);

  public abstract string GetVRChatRegistryKeyString(string key);

  public abstract bool SetVRChatRegistryKey(string key, object value, int typeInt);

  public abstract void SetVRChatRegistryKey(string key, byte[] value);

  public abstract Dictionary<string, Dictionary<string, object>> GetVRChatRegistry();

  public abstract void SetVRChatRegistry(string json);

  public abstract bool HasVRChatRegistryFolder();

  public abstract void DeleteVRChatRegistryFolder();

  public abstract string ReadVrcRegJsonFile(string filepath);

  public abstract string AddScreenshotMetadata(
    string path,
    string metadataString,
    string worldId,
    bool changeFilename = false);

  public void PopulateImageHosts(string json)
  {
    ImageCache.PopulateImageHosts(System.Text.Json.JsonSerializer.Deserialize<List<string>>(json));
  }

  public async Task<string> GetImage(string url, string fileId, string version)
  {
    return await ImageCache.GetImage(url, fileId, version);
  }

  public string ResizeImageToFitLimits(string base64data)
  {
    return Convert.ToBase64String(this.ResizeImageToFitLimits(Convert.FromBase64String(base64data), false));
  }

  public byte[] ResizeImageToFitLimits(
    byte[] imageData,
    bool matchingDimensions,
    int maxWidth = 2000,
    int maxHeight = 2000,
    long maxSize = 10000000)
  {
    using (MemoryStream memoryStream = new MemoryStream(imageData))
    {
      Image image = Image.Load((Stream) memoryStream);
      if ((!matchingDimensions || image.Width == image.Height) && image.Metadata.DecodedImageFormat == PngFormat.Instance && (long) imageData.Length < maxSize && image.Width <= maxWidth && image.Height <= maxHeight)
        return imageData;
      if (image.Width > maxWidth)
      {
        double num = (double) image.Width / (double) maxWidth;
        int newHeight = (int) Math.Round((double) image.Height / num);
        image.Mutate((Action<IImageProcessingContext>) (x => x.Resize(maxWidth, newHeight)));
      }
      if (image.Height > maxHeight)
      {
        double num = (double) image.Height / (double) maxHeight;
        int newWidth = (int) Math.Round((double) image.Width / num);
        image.Mutate((Action<IImageProcessingContext>) (x => x.Resize(newWidth, maxHeight)));
      }
      if (matchingDimensions && image.Width != image.Height)
      {
        int num = Math.Max(image.Width, image.Height);
        Image<Rgba32> source = new Image<Rgba32>(num, num);
        int xOffset = (num - image.Width) / 2;
        int yOffset = (num - image.Height) / 2;
        source.Mutate<Rgba32>((Action<IImageProcessingContext>) (x => x.DrawImage(image, new Point(xOffset, yOffset), 1f)));
        image = (Image) source;
      }
      SaveToFileToUpload();
      for (int index = 0; index < 250 && (long) imageData.Length > maxSize; ++index)
      {
        SaveToFileToUpload();
        if ((long) imageData.Length >= maxSize)
        {
          int newWidth;
          int newHeight;
          if (image.Width > image.Height)
          {
            newWidth = image.Width - 25;
            newHeight = (int) Math.Round((double) image.Height / ((double) image.Width / (double) newWidth));
          }
          else
          {
            newHeight = image.Height - 25;
            newWidth = (int) Math.Round((double) image.Width / ((double) image.Height / (double) newHeight));
          }
          image.Mutate((Action<IImageProcessingContext>) (x => x.Resize(newWidth, newHeight)));
        }
        else
          break;
      }
      if ((long) imageData.Length > maxSize)
        throw new Exception("Failed to get image into target filesize.");
      image.Dispose();
      return imageData;

      void SaveToFileToUpload()
      {
        using (MemoryStream memoryStream = new MemoryStream())
        {
          image.SaveAsPng((Stream) memoryStream);
          imageData = memoryStream.ToArray();
        }
      }
    }
  }

  public byte[] ResizePrintImage(byte[] imageData)
  {
    using (MemoryStream memoryStream1 = new MemoryStream(imageData))
    {
      Image image = Image.Load((Stream) memoryStream1);
      if (image.Height > image.Width)
        image.Mutate((Action<IImageProcessingContext>) (x => x.Rotate(RotateMode.Rotate270)));
      if (image.Width < 1920 || image.Height < 1080)
      {
        Image<Rgba32> source = new Image<Rgba32>(1920, 1080);
        double num = (double) image.Width / (double) image.Height;
        int width;
        int height;
        int xOffset;
        int yOffset;
        if (num > 16.0 / 9.0)
        {
          width = 1920;
          height = (int) ((double) width / num);
          xOffset = 0;
          yOffset = (1080 - height) / 2;
        }
        else
        {
          height = 1080;
          width = (int) ((double) height * num);
          xOffset = (1920 - width) / 2;
          yOffset = 0;
        }
        using (Image scaledImage = image.Clone((Action<IImageProcessingContext>) (ctx => ctx.Resize(width, height))))
        {
          source.Mutate<Rgba32>((Action<IImageProcessingContext>) (x => x.Fill(Color.White).DrawImage(scaledImage, new Point(xOffset, yOffset), 1f)));
          image = (Image) source;
        }
      }
      if (image.Width > 1920)
      {
        double num = (double) image.Width / 1920.0;
        int newHeight = (int) Math.Round((double) image.Height / num);
        image.Mutate((Action<IImageProcessingContext>) (x => x.Resize(1920, newHeight)));
      }
      if (image.Height > 1080)
      {
        double num = (double) image.Height / 1080.0;
        int newWidth = (int) Math.Round((double) image.Width / num);
        image.Mutate((Action<IImageProcessingContext>) (x => x.Resize(newWidth, 1080)));
      }
      using (Image<Rgba32> source = new Image<Rgba32>(2048 /*0x0800*/, 1440))
      {
        source.Mutate<Rgba32>((Action<IImageProcessingContext>) (x => x.Fill(Color.White)));
        Point borderPoint = new Point((2048 /*0x0800*/ - image.Width) / 2, 69);
        source.Mutate<Rgba32>((Action<IImageProcessingContext>) (x => x.DrawImage(image, borderPoint, 1f)));
        using (MemoryStream memoryStream2 = new MemoryStream())
        {
          source.SaveAsPng((Stream) memoryStream2);
          return memoryStream2.ToArray();
        }
      }
    }
  }

  public async Task CropAllPrints(string ugcFolderPath)
  {
    string path = Path.Join(this.GetUGCPhotoLocation(ugcFolderPath), "Prints");
    if (!Directory.Exists(path))
      return;
    string[] strArray = Directory.GetFiles(path, "*.png", SearchOption.AllDirectories);
    for (int index = 0; index < strArray.Length; ++index)
    {
      int num = await this.CropPrintImage(strArray[index]) ? 1 : 0;
    }
    strArray = (string[]) null;
  }

  public async Task<bool> CropPrintImage(string path)
  {
    string tempPath = path + ".temp";
    Image image = await Image.LoadAsync((Stream) new MemoryStream(await System.IO.File.ReadAllBytesAsync(path)));
    if (!this.CropPrint(ref image))
      return false;
    await image.SaveAsPngAsync(tempPath);
    if (ScreenshotHelper.HasTXt(path))
      ScreenshotHelper.CopyTXt(path, tempPath);
    System.IO.File.Move(tempPath, path, true);
    return true;
  }

  public bool CropPrint(ref Image image)
  {
    if (image.Width != 2048 /*0x0800*/ || image.Height != 1440)
      return false;
    Rectangle rectangle = new Rectangle(new Point(64 /*0x40*/, 69), new Size(1920, 1080));
    image.Mutate((Action<IImageProcessingContext>) (x => x.Crop(rectangle)));
    return true;
  }

  public async Task<string> SavePrintToFile(
    string url,
    string ugcFolderPath,
    string monthFolder,
    string fileName)
  {
    string str = Path.Join(this.GetUGCPhotoLocation(ugcFolderPath), "Prints", AppApi.MakeValidFileName(monthFolder));
    Directory.CreateDirectory(str);
    string filePath = Path.Join(str, AppApi.MakeValidFileName(fileName));
    if (System.IO.File.Exists(filePath))
      return (string) null;
    try
    {
      await ImageCache.SaveImageToFile(url, filePath);
    }
    catch (Exception ex)
    {
      AppApi.logger.Error(ex, "Failed to save print to file");
      return (string) null;
    }
    return filePath;
  }

  public async Task<string> SaveStickerToFile(
    string url,
    string ugcFolderPath,
    string monthFolder,
    string fileName)
  {
    string str = Path.Join(this.GetUGCPhotoLocation(ugcFolderPath), "Stickers", AppApi.MakeValidFileName(monthFolder));
    Directory.CreateDirectory(str);
    string filePath = Path.Join(str, AppApi.MakeValidFileName(fileName));
    if (System.IO.File.Exists(filePath))
      return (string) null;
    try
    {
      await ImageCache.SaveImageToFile(url, filePath);
    }
    catch (Exception ex)
    {
      AppApi.logger.Error(ex, "Failed to save print to file");
      return (string) null;
    }
    return filePath;
  }

  public Dictionary<string, short> GetVRChatModerations(string currentUserId)
  {
    string path = Path.Join(this.GetVRChatAppDataLocation(), $"LocalPlayerModerations\\{currentUserId}-show-hide-user.vrcset");
    if (!System.IO.File.Exists(path))
      return (Dictionary<string, short>) null;
    Dictionary<string, short> vrChatModerations = new Dictionary<string, short>();
    using (StreamReader streamReader = new StreamReader(path))
    {
      string str;
      while ((str = streamReader.ReadLine()) != null)
      {
        int length = str.IndexOf(' ');
        if (length > 0)
        {
          string key = str.Substring(0, length);
          short num = short.Parse(str.Substring(str.Length - 3));
          vrChatModerations.Add(key, num);
        }
      }
      return vrChatModerations;
    }
  }

  public short GetVRChatUserModeration(string currentUserId, string userId)
  {
    string path = Path.Join(this.GetVRChatAppDataLocation(), $"LocalPlayerModerations\\{currentUserId}-show-hide-user.vrcset");
    if (!System.IO.File.Exists(path))
      return 0;
    using (StreamReader streamReader = new StreamReader(path))
    {
      string str;
      while ((str = streamReader.ReadLine()) != null)
      {
        int length = str.IndexOf(' ');
        if (length > 0 && userId == str.Substring(0, length))
          return short.Parse(str.Substring(str.Length - 3));
      }
      return 0;
    }
  }

  public bool SetVRChatUserModeration(string currentUserId, string userId, int type)
  {
    string path = Path.Join(this.GetVRChatAppDataLocation(), $"LocalPlayerModerations\\{currentUserId}-show-hide-user.vrcset");
    if (!System.IO.File.Exists(path))
      return false;
    List<string> list = ((IEnumerable<string>) System.IO.File.ReadAllLines(path)).ToList<string>();
    int index = list.FindIndex((Predicate<string>) (x => x.StartsWith(userId)));
    if (index >= 0)
      list.RemoveAt(index);
    if (type != 0)
    {
      StringBuilder stringBuilder = new StringBuilder(userId);
      while (stringBuilder.Length < 64 /*0x40*/)
        stringBuilder.Append(' ');
      stringBuilder.Append(type.ToString("000"));
      list.Add(stringBuilder.ToString());
    }
    try
    {
      System.IO.File.WriteAllLines(path, (IEnumerable<string>) list);
    }
    catch (Exception ex)
    {
      return false;
    }
    return true;
  }

  private static void InitializeOvrTk()
  {
    lock (AppApi._ovrtLock)
    {
      if (AppApi._ovrtWebsocketClient != null)
        return;
      Func<ClientWebSocket> func = (Func<ClientWebSocket>) (() =>
      {
        ClientWebSocket clientWebSocket = new ClientWebSocket();
        clientWebSocket.Options.KeepAliveInterval = TimeSpan.FromSeconds(5L);
        clientWebSocket.Options.SetRequestHeader("user-agent", Program.Version);
        return clientWebSocket;
      });
      AppApi._ovrtWebsocketClient = new WebsocketClient(AppApi._ovrtWebsocketUri, func)
      {
        Name = "OVRToolkit Websocket",
        ReconnectTimeout = new TimeSpan?(),
        ErrorReconnectTimeout = new TimeSpan?(TimeSpan.FromSeconds(30L))
      };
      AppApi._ovrtWebsocketClient.ReconnectionHappened.Subscribe<ReconnectionInfo>((Action<ReconnectionInfo>) (info => { }));
      AppApi._ovrtWebsocketClient.DisconnectionHappened.Subscribe<DisconnectionInfo>((Action<DisconnectionInfo>) (info => { }));
      AppApi._ovrtWebsocketClient.MessageReceived.Subscribe<ResponseMessage>((Action<ResponseMessage>) (msg => { }));
      AppApi._ovrtWebsocketClient.Start().Wait();
    }
  }

  private static void SendMessages(IEnumerable<AppApi.OvrtMessage> ovrtMessages)
  {
    if (ovrtMessages == null || !ovrtMessages.Any<AppApi.OvrtMessage>())
      return;
    if (AppApi._ovrtWebsocketClient == null)
      AppApi.InitializeOvrTk();
    if (!AppApi._ovrtWebsocketClient.IsRunning)
      return;
    foreach (AppApi.OvrtMessage ovrtMessage in ovrtMessages)
      AppApi._ovrtWebsocketClient.Send(System.Text.Json.JsonSerializer.Serialize<AppApi.OvrtMessage>(ovrtMessage));
  }

  public void OVRTNotification(
    bool hudNotification,
    bool wristNotification,
    string title,
    string body,
    int timeout,
    string image = "")
  {
    List<AppApi.OvrtMessage> ovrtMessageList = new List<AppApi.OvrtMessage>();
    byte[] numArray = string.IsNullOrWhiteSpace(image) || !System.IO.File.Exists(image) ? AppApi._vrcxIcon : System.IO.File.ReadAllBytes(image);
    if (wristNotification)
      ovrtMessageList.Add(new AppApi.OvrtMessage()
      {
        MessageType = "SendWristNotification",
        Json = System.Text.Json.JsonSerializer.Serialize<AppApi.OvrtWristNotificationMessage>(new AppApi.OvrtWristNotificationMessage()
        {
          Body = $"{title} - {body}"
        })
      });
    if (hudNotification)
      ovrtMessageList.Add(new AppApi.OvrtMessage()
      {
        MessageType = "SendNotification",
        Json = System.Text.Json.JsonSerializer.Serialize<AppApi.OvrtHudNotificationMessage>(new AppApi.OvrtHudNotificationMessage()
        {
          Title = title,
          Body = body,
          Icon = numArray
        })
      });
    AppApi.SendMessages((IEnumerable<AppApi.OvrtMessage>) ovrtMessageList);
  }

  public string GetExtraScreenshotData(string path, bool carouselCache)
  {
    string withoutExtension = Path.GetFileNameWithoutExtension(path);
    JObject jobject = new JObject();
    if (!System.IO.File.Exists(path) || !path.EndsWith(".png"))
      return (string) null;
    string[] files = Directory.GetFiles(Path.GetDirectoryName(path), "*.png");
    if (carouselCache)
    {
      int num = Array.IndexOf<string>(files, path);
      if (num > 0)
        jobject.Add("previousFilePath", (JToken) files[num - 1]);
      if (num < files.Length - 1)
        jobject.Add("nextFilePath", (JToken) files[num + 1]);
    }
    jobject.Add("fileResolution", (JToken) ScreenshotHelper.ReadPNGResolution(path));
    DateTime creationTime = System.IO.File.GetCreationTime(path);
    jobject.Add("creationDate", (JToken) creationTime.ToString("yyyy-MM-dd HH:mm:ss"));
    long length = new FileInfo(path).Length;
    jobject.Add("fileSizeBytes", (JToken) length.ToString());
    jobject.Add("fileName", (JToken) withoutExtension);
    jobject.Add("filePath", (JToken) path);
    jobject.Add("fileSize", (JToken) (((float) ((double) length / 1024.0 / 1024.0)).ToString("0.00") + " MB"));
    return jobject.ToString(Formatting.Indented);
  }

  public string GetScreenshotMetadata(string path)
  {
    if (string.IsNullOrEmpty(path))
      return (string) null;
    ScreenshotMetadata screenshotMetadata = ScreenshotHelper.GetScreenshotMetadata(path);
    if (screenshotMetadata == null)
      return new JObject()
      {
        {
          "sourceFile",
          (JToken) path
        },
        {
          "error",
          (JToken) "Screenshot contains no metadata."
        }
      }.ToString(Formatting.Indented);
    if (screenshotMetadata.Error != null)
      return new JObject()
      {
        {
          "sourceFile",
          (JToken) path
        },
        {
          "error",
          (JToken) screenshotMetadata.Error
        }
      }.ToString(Formatting.Indented);
    return JsonConvert.SerializeObject((object) screenshotMetadata, Formatting.Indented, new JsonSerializerSettings()
    {
      ContractResolver = (IContractResolver) new DefaultContractResolver()
      {
        NamingStrategy = (NamingStrategy) new CamelCaseNamingStrategy()
      }
    });
  }

  public string FindScreenshotsBySearch(string searchQuery, int searchType = 0)
  {
    Stopwatch stopwatch = new Stopwatch();
    stopwatch.Start();
    string chatPhotosLocation = this.GetVRChatPhotosLocation();
    List<ScreenshotMetadata> screenshots = ScreenshotHelper.FindScreenshots(searchQuery, chatPhotosLocation, (ScreenshotHelper.ScreenshotSearchType) searchType);
    JArray jarray = new JArray();
    foreach (ScreenshotMetadata screenshotMetadata in screenshots)
      jarray.Add((JToken) screenshotMetadata.SourceFile);
    stopwatch.Stop();
    AppApi.logger.Info($"FindScreenshotsBySearch took {stopwatch.ElapsedMilliseconds}ms to complete.");
    return jarray.ToString();
  }

  public string GetLastScreenshot()
  {
    string chatPhotosLocation = this.GetVRChatPhotosLocation();
    // ISSUE: reference to a compiler-generated field
    // ISSUE: reference to a compiler-generated field
    return !Directory.Exists(chatPhotosLocation) ? (string) null : ((IEnumerable<string>) Directory.GetFiles(chatPhotosLocation, "*.png", SearchOption.AllDirectories)).Where<string>((Func<string, bool>) (x => !Regex.IsMatch(x, "\\\\Prints\\\\|\\\\Stickers\\\\", RegexOptions.IgnoreCase))).OrderByDescending<string, DateTime>(AppApi.\u003C\u003EO.\u003C0\u003E__GetCreationTime ?? (AppApi.\u003C\u003EO.\u003C0\u003E__GetCreationTime = new Func<string, DateTime>(Directory.GetCreationTime))).FirstOrDefault<string>();
  }

  public async Task DownloadUpdate(
    string fileUrl,
    string fileName,
    string hashUrl,
    int downloadSize)
  {
    await Update.DownloadUpdate(fileUrl, fileName, hashUrl, downloadSize);
  }

  public void CancelUpdate() => Update.CancelUpdate();

  public int CheckUpdateProgress() => Update.UpdateProgress;

  private static string MakeValidFileName(string name)
  {
    name = name.Replace("/", "");
    name = name.Replace("\\", "");
    name = AppApi._folderRegex.Replace(name, "");
    name = AppApi._fileRegex.Replace(name, "");
    return name;
  }

  public string ReadConfigFile()
  {
    string chatAppDataLocation = this.GetVRChatAppDataLocation();
    string path = Path.Join(chatAppDataLocation, "config.json");
    return !Directory.Exists(chatAppDataLocation) || !System.IO.File.Exists(path) ? string.Empty : System.IO.File.ReadAllText(path);
  }

  public void WriteConfigFile(string json)
  {
    System.IO.File.WriteAllText(Path.Join(this.GetVRChatAppDataLocation(), "config.json"), json);
  }

  public void XSNotification(string title, string content, int timeout, string image = "")
  {
    Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
    IPEndPoint remoteEP = new IPEndPoint(IPAddress.Loopback, 42069);
    bool flag = false;
    string str = image;
    if (string.IsNullOrEmpty(image))
    {
      flag = true;
    float num = 110f;
    if (content.Length > 300)
      num = 250f;
    else if (content.Length > 200)
      num = 200f;
    else if (content.Length > 100)
      num = 150f;
    socket.SendTo(System.Text.Json.JsonSerializer.SerializeToUtf8Bytes<AppApi.XSOMessage>(new AppApi.XSOMessage()
    {
      messageType = 1,
      title = title,
      content = content,
      height = num,
      sourceApp = "VRCX",
      timeout = (float) timeout,
      audioPath = string.Empty,
      useBase64Icon = flag,
      icon = str
    }), (EndPoint) remoteEP);
    socket.Close();
  }

  private struct OvrtMessage
  {
    [JsonPropertyName("messageType")]
    public string MessageType { get; set; }

    [JsonPropertyName("json")]
    public string Json { get; set; }
  }

  private struct OvrtHudNotificationMessage
  {
    [JsonPropertyName("title")]
    public string Title { get; set; }

    [JsonPropertyName("body")]
    public string Body { get; set; }

    [JsonPropertyName("icon")]
    public byte[] Icon { get; set; }
  }

  private struct OvrtWristNotificationMessage
  {
    [JsonPropertyName("body")]
    public string Body { get; set; }
  }

  private struct XSOMessage
  {
    public int messageType { get; set; }

    public int index { get; set; }

    public float volume { get; set; }

    public string audioPath { get; set; }

    public float timeout { get; set; }

    public string title { get; set; }

    public string content { get; set; }

    public string icon { get; set; }

    public float height { get; set; }

    public float opacity { get; set; }

    public bool useBase64Icon { get; set; }

    public string sourceApp { get; set; }
  }
}
